<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Tutorial &mdash; ClearMap 0.9.2 documentation</title>
    
    <link rel="stylesheet" href="_static/clearmap.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.9.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/copybutton.js"></script>
    <link rel="top" title="ClearMap 0.9.2 documentation" href="index.html" />
    <link rel="next" title="ClearMap Image Analysis Tools" href="imageanalysis.html" />
    <link rel="prev" title="Installation" href="installation.html" />
 
    <script type="text/javascript">
      // intelligent scrolling of the sidebar content
      $(window).scroll(function() {
        var sb = $('.sphinxsidebarwrapper');
        var win = $(window);
        var sbh = sb.height();
        var offset = $('.sphinxsidebar').position()['top'];
        var wintop = win.scrollTop();
        var winbot = wintop + win.innerHeight();
        var curtop = sb.position()['top'];
        var curbot = curtop + sbh;
        // does sidebar fit in window?
        if (sbh < win.innerHeight()) {
          // yes: easy case -- always keep at the top
          sb.css('top', $u.min([$u.max([0, wintop - offset - 10]),
                                $(document).height() - sbh - 200]));
        } else {
          // no: only scroll if top/bottom edge of sidebar is at
          // top/bottom edge of window
          if (curtop > wintop && curbot > winbot) {
            sb.css('top', $u.max([wintop - offset - 10, 0]));
          } else if (curtop < wintop && curbot < winbot) {
            sb.css('top', $u.min([winbot - sbh - offset - 20,
                                  $(document).height() - sbh - 200]));
          }
        }
      });
    </script>


  </head>
  <body role="document">
<div style="background-color: #e2e8e9; text-align: left; padding: 10px 10px 15px 15px">
<p style="font-size: 30px; color: color: #11557C"> <a href="index.html" style="color: #11557C; font-weight: bold">ClearMap iDISCO+ Toolbox Documentation</a></p>
<a href="index.html"><img src="_static/brain_bw_small.jpg" height=50px width=150% border="0" alt="ClearMap"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="imageanalysis.html" title="ClearMap Image Analysis Tools"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="installation.html" title="Installation"
             accesskey="P">previous</a> |</li>
       <li><a href="index.html">home</a>|&nbsp;</li>
       <li><a href="search.html">search</a>|&nbsp;</li>
       <li><a href="api/ClearMap.html">documentation </a> &raquo;</li>
 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h3><a href="index.html">Table Of Contents</a></h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Overview of ClearMap</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#the-parameter-file">The Parameter File</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#import-modules"><cite>Import Modules</cite></a></li>
<li class="toctree-l3"><a class="reference internal" href="#data-parameters"><cite>Data parameters</cite></a></li>
<li class="toctree-l3"><a class="reference internal" href="#cell-detection"><cite>Cell detection</cite></a></li>
<li class="toctree-l3"><a class="reference internal" href="#heat-map-generation"><cite>Heat map generation</cite></a></li>
<li class="toctree-l3"><a class="reference internal" href="#config-parameters"><cite>Config parameters</cite></a></li>
<li class="toctree-l3"><a class="reference internal" href="#run-parameters"><cite>Run Parameters</cite></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#the-run-file">The Run File</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#resampling-operations"><cite>Resampling operations</cite></a></li>
<li class="toctree-l3"><a class="reference internal" href="#alignment-operations"><cite>Alignment operations</cite></a></li>
<li class="toctree-l3"><a class="reference internal" href="#cell-detection-and-thresholding"><cite>Cell detection and thresholding</cite></a></li>
<li class="toctree-l3"><a class="reference internal" href="#point-coordinate-transformation"><cite>Point coordinate transformation</cite></a></li>
<li class="toctree-l3"><a class="reference internal" href="#heat-map"><cite>Heat map</cite></a></li>
<li class="toctree-l3"><a class="reference internal" href="#table-generation"><cite>Table generation</cite></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#analysis-tools">Analysis Tools</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#voxel-statistics"><cite>Voxel statistics</cite></a></li>
<li class="toctree-l3"><a class="reference internal" href="#regions-statistics"><cite>Regions statistics</cite></a></li>
<li class="toctree-l3"><a class="reference internal" href="#automated-region-isolation"><cite>Automated region isolation</cite></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="imageanalysis.html">ClearMap Image Analysis Tools</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="api/ClearMap.html">ClearMap package</a></li>
</ul>
 
  <h4>Previous topic</h4>
  <p class="topless"><a href="installation.html"
                        title="previous chapter">Installation</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="imageanalysis.html"
                        title="next chapter">ClearMap Image Analysis Tools</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/tutorial.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="tutorial">
<h1>Tutorial<a class="headerlink" href="#tutorial" title="Permalink to this headline">¶</a></h1>
<p>The goal of this tutorial is to explain the scripts we used to analyze samples. As an example, we will use a dataset from a Light Sheet imaged adult mouse brain stained for c-fos. The tutorial files also contain an autofluorescence file to enable the registration of the scan to the reference atlas. The tutorial files are found in the ClearMap/Scripts folder. They consist of :</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#the-parameter-file">The Parameter File</a> This sets the parameters individually for each sample</li>
<li><a class="reference internal" href="#the-run-file">The Run File</a> This will run all the commands to process each sample individually</li>
<li><a class="reference internal" href="#analysis-tools">Analysis Tools</a> This scripts will run the analysis tools and group statistics for all samples in the batch</li>
</ul>
</div></blockquote>
<p>A project will usually contain 1 parameter file for each sample, 1 run file for the whole experiment and 1 analysis file for the whole experiment.</p>
<div class="section" id="the-parameter-file">
<h2>The Parameter File<a class="headerlink" href="#the-parameter-file" title="Permalink to this headline">¶</a></h2>
<p>The parameter is a Python script that will contain all the necessary informations to process each sample. An example script, <em>parameter_file_template.py</em> is provided in the ClearMap/Scripts folder. Open this file to follow closely the tutorial. It contains the following sections:</p>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="78%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Section</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="#import-modules">Import modules</a></td>
<td>load from ClearMap the functions used here</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#data-parameters">Data parameters</a></td>
<td>points to the files used, their resolution and orientation</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cell-detection">Cell detection</a></td>
<td>parameters for the cell detection, and module used</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#heat-map-generation">Heat map generation</a></td>
<td>to generate a voxelized map of the detected cells</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#config-parameters">Config Parameters</a></td>
<td>the parameters for memory and processors management</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#run-parameters">Run Parameters</a></td>
<td>you would usually not change these. They specify how the data will be processed</td>
</tr>
</tbody>
</table>
<div class="section" id="import-modules">
<h3><cite>Import Modules</cite><a class="headerlink" href="#import-modules" title="Permalink to this headline">¶</a></h3>
<p>You would usually not change these. They are all the functions that will be used later either in the parameter file or in the  execution file.</p>
</div>
<div class="section" id="data-parameters">
<h3><cite>Data parameters</cite><a class="headerlink" href="#data-parameters" title="Permalink to this headline">¶</a></h3>
<p>This is where you point to the files used, their resolution and orientation. It also defines which atlas and annotation files to use.</p>
<p>To set the directory where all files will be read and written for this sample:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">BaseDirectory</span> <span class="o">=</span> <span class="s">&#39;/home/mtllab/pharmaco/sample1&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>To set the image files used for the processing:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cFosFile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">BaseDirectory</span><span class="p">,</span> <span class="s">&#39;cfos/0_8x-cfos-Table Z\d{4}.ome.tif&#39;</span><span class="p">);</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">AutofluoFile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">BaseDirectory</span><span class="p">,</span> \
<span class="gp">&gt;&gt;&gt; </span>                            <span class="s">&#39;autofluo/0_8xs3-autofluo-Table Z\d{4}.ome.tif&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>Note the use of the command <code class="docutils literal"><span class="pre">os.path.join</span></code> to link the set <code class="docutils literal"><span class="pre">BaseDirectory</span></code> with the folder where the files are. On the LaVision ultramicroscope system, the images files are generated not as stacks, but as numbered files in the ome.tif format. Each Z stack will end by <code class="docutils literal"><span class="pre">-Table</span> <span class="pre">Z0000.ome.tif</span></code>. The 0000 is the plane number. To indicate <strong>ClearMap</strong> to read the next planes, replace the 4 digits with the command <code class="docutils literal"><span class="pre">\d{4}</span></code>. On our system, files for each channel (here, c-fos and background fluorescence) are saved in a different stack, in a different folder.</p>
<p>To restrict the range for the object detection:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cFosFileRange</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;x&#39;</span> <span class="p">:</span> <span class="nb">all</span><span class="p">,</span> <span class="s">&#39;y&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="mi">180</span><span class="p">,</span> <span class="mi">2600</span><span class="p">),</span> <span class="s">&#39;z&#39;</span> <span class="p">:</span> <span class="nb">all</span><span class="p">};</span>
</pre></div>
</div>
<p>This range will only affect the region used for the cell detection. It will not be taken into account for the 3D image registration to the reference Atlas, nor for the voxelization or other analysis. This is useful to limit the amount of memory used. In our example, we use the full x range, the full z range, but restrict the y range. The camera on our system, an Andor sNEO CMOS, has a sensor size of 2160 x 2660. However, the lens used on for the acquisition, an Olympus 2X 0.5NA MVPLAPO, has a strong corner deformation, so we restrict the y range because no cells can be reliably detected outside of this range.</p>
<p>As a reminder, in the image files, the (0, 0, 0) coordinate corresponds to the upper left corner of the first plane. To the opposite, the (2160, 2660, 2400) coordinate will be the bottom right corner of the last plane (here 2400, but can vary).</p>
<p>When optimizing the parameters for the object detection, you should dramatically restrict the range to speed up the detection. We recommend using 500 planes, 500 pixels on each side:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cFosFileRange</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;x&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="mi">500</span><span class="p">,</span> <span class="mi">1000</span><span class="p">),</span> <span class="s">&#39;y&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="mi">500</span><span class="p">,</span> <span class="mi">1000</span><span class="p">),</span> <span class="s">&#39;z&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="mi">500</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)};</span>
</pre></div>
</div>
<p>But of course adapting the range to where the relevant objects are on your sample.</p>
<p>Next, to set the resolution of the original data (in µm / pixel):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">OriginalResolution</span> <span class="o">=</span> <span class="p">(</span><span class="mf">4.0625</span><span class="p">,</span> <span class="mf">4.0625</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</pre></div>
</div>
<p>In this example, this is set for a zoom factor of 0.8X on the LaVision system with the 2X lens. This information can be found in the metadata of the tif file usually. If you don’t know the pixel size, we recommend opening the stack with the plugin BioFormat on ImageJ, and going to «&nbsp;image&nbsp;» -&gt; «&nbsp;show info&nbsp;» to read the metadata. On the LaVision file, this information is at the end of the list.</p>
<p>The orientation of the sample has to be set to match the orientation of the Atlas reference files. It is not mandatory to acquire the sample in the same orientation as the atlas. For instance, you can acquire the left side of the brain, and map it onto the right side of the atlas:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">FinalOrientation</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
</pre></div>
</div>
<p>The convention is as follow (examples given, any configuration is possible):</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="75%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Value of the tuple</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>(1, 2, 3)</td>
<td>The scan has the same orientation as the atlas reference</td>
</tr>
<tr class="row-odd"><td>(-1, 2, 3)</td>
<td>The x axis is mirrored compared to the atlas</td>
</tr>
<tr class="row-even"><td>(1, -2, 3)</td>
<td>The y axis is mirrored compared to the atlas</td>
</tr>
<tr class="row-odd"><td>(2, 1, 3)</td>
<td>Performs a rotation by exchanging the x and y axis</td>
</tr>
<tr class="row-even"><td>(3, 2, 1)</td>
<td>Performs a rotation by exchanging the z and x axis</td>
</tr>
</tbody>
</table>
<p>For our samples, we use the following orientation to match our atlas files:</p>
<blockquote>
<div><ul class="simple">
<li>The right side of the brain is facing the objective, lateral side up.</li>
<li>The rostral side of the brain is up</li>
<li>The dorsal side is facing left</li>
<li>The ventral side is facing right</li>
</ul>
</div></blockquote>
<p>This means that in our scans, if we want to image the right hemisphere, we use (1, 2, 3) and if we want to image the left hemisphere, we use (-1, 2, 3).</p>
<p>To set the output for the voxelized heat map file:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">VoxelizationFile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">BaseDirectory</span><span class="p">,</span> <span class="s">&#39;points_voxelized.tif&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>To set the resolution of the Atlas Files (in µm/ pixel):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">AtlasResolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">25</span><span class="p">);</span>
</pre></div>
</div>
<p>To choose which atlas files you would like to use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">PathReg</span>        <span class="o">=</span> <span class="s">&#39;/home/mtllab/Documents/warping&#39;</span><span class="p">;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">AtlasFile</span>      <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">PathReg</span><span class="p">,</span> <span class="s">&#39;half_template_25_right.tif&#39;</span><span class="p">);</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">AnnotationFile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">PathReg</span><span class="p">,</span> <span class="s">&#39;annotation_25_right.tif&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>It is important to make sure that the Atlas used is in the correct orientation (see above), but also don’t contain too much information outside of the field of view. While the registration program can deal with a bit of extra «&nbsp;bleed&nbsp;» outside of the sample, this should be kept to a minimum. We usually prepare different crops of the atlas file to match the usual field of views we acquire.</p>
</div>
<div class="section" id="cell-detection">
<h3><cite>Cell detection</cite><a class="headerlink" href="#cell-detection" title="Permalink to this headline">¶</a></h3>
<p>At this point, two detection methods exist: the <code class="docutils literal"><span class="pre">SpotDetection</span></code> and <code class="docutils literal"><span class="pre">Ilastik</span></code>:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">SpotDetection</span></code> is designed for globular objects, such as neuron cell bodies or nuclei. This is the fastest method, and offers a greater degree of fine controls over the sensitivity of the detection. However, it is not well suited for complex objects.</li>
<li><code class="docutils literal"><span class="pre">Ilastik</span></code> is a framework that relies on the user generating a classifier through the graphical interface of the Ilastik program, by painting over a few objects and over the background. The program will then learn to classify the pixels between objects or backgrounds based on the user indications. This is a very easy way to tune very complex filters to detect complex objects or textures. However, the classification is a black box, and very dependent of the user’s classification.</li>
</ul>
</div></blockquote>
<p>In this tutorial, we will use the SpotDetection method. To choose which method to use for the cell detection, set the variable as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ImageProcessingMethod</span> <span class="o">=</span> <span class="s">&quot;SpotDetection&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>The parameters for the Spot Detection methods are then sorted in «&nbsp;dictionaries&nbsp;» by theme :</p>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Dictionary name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>correctIlluminationParameter</td>
<td>If you have an intensity profile for your microscope, you can correct variations in illuminations here</td>
</tr>
<tr class="row-odd"><td>removeBackgroundParameter</td>
<td>To set the background subtraction via morphological opening</td>
</tr>
<tr class="row-even"><td>filterDoGParameter</td>
<td>To set the parameters for the Difference of Gaussian filter</td>
</tr>
<tr class="row-odd"><td>findExtendedMaximaParameter</td>
<td>If the object contains multiple peaks of intensity, this will collapse them into one peak</td>
</tr>
<tr class="row-even"><td>findIntensityParameter</td>
<td>Often, the center of the mass of an object is not the voxel of highest intensity. This is a correction for this</td>
</tr>
<tr class="row-odd"><td>detectCellShapeParameter</td>
<td>This sets the parameters for the cell shape filling via watershed</td>
</tr>
</tbody>
</table>
<div class="section" id="correcting-the-illumination">
<h4>Correcting the illumination:<a class="headerlink" href="#correcting-the-illumination" title="Permalink to this headline">¶</a></h4>
<p>Because of the Gaussian shape of the light sheet and of the objecting lens vignetting, the sample illumination is not uniform. While correcting the illumination can improve the uniformity of the cell detection, it is usually not really necessary if all samples where imaged the same way, as the same anatomical features will be positioned in the same region of the lens across samples. Nevertheless, to correct for variation in the illumination use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">correctIlluminationParameter</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>   <span class="s">&quot;flatfield&quot;</span>  <span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>   <span class="s">&quot;background&quot;</span> <span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>   <span class="s">&quot;scaling&quot;</span>    <span class="p">:</span> <span class="s">&quot;Mean&quot;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>   <span class="s">&quot;save&quot;</span>       <span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>   <span class="s">&quot;verbose&quot;</span>    <span class="p">:</span> <span class="bp">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">}</span>
</pre></div>
</div>
<p>For this tutorial, we will not use the correction, so the <code class="docutils literal"><span class="pre">flatfield</span></code> parameter is set to <code class="docutils literal"><span class="pre">None</span></code>. Please note that you need to generate an intensity profile for your system if you wish to use this function.</p>
</div>
<div class="section" id="background-subtraction">
<h4>Background Subtraction:<a class="headerlink" href="#background-subtraction" title="Permalink to this headline">¶</a></h4>
<p>This is the most important pre-treatment step, usually always turned on. The background subtraction via morphological opening is not very sensitive to the size parameter used, as long as it is in the range of the size of the objects detected. The parameters for the background subtraction are as follow:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">removeBackgroundParameter</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s">&quot;size&quot;</span>    <span class="p">:</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">7</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s">&quot;save&quot;</span>    <span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s">&quot;verbose&quot;</span> <span class="p">:</span> <span class="bp">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">}</span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal"><span class="pre">size</span></code> is a tuple with (x,y) in pixels and correspond to an ellipsoid of this size. Of importance, you can check the result of the background subtraction by setting the <code class="docutils literal"><span class="pre">save</span></code> parameter to a filename. This will output a series of tif images you can open with ImageJ to check the results. For instance you could set <code class="docutils literal"><span class="pre">save</span></code> like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span>    <span class="s">&quot;save&quot;</span>    <span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">BaseDirectory</span><span class="p">,</span> <span class="s">&#39;background/background\d{4}.ome.tif&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>You have to use the <code class="docutils literal"><span class="pre">\d{4}</span></code> notation to save the files as a series of images, otherwise only the first plane is saved!</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Only use the <code class="docutils literal"><span class="pre">save</span></code> function when you analyse a small subset of your data, otherwise the full stack will be written to the disk. Don’t forget to turn off this parameter when you’re done optimizing the filters.</p>
</div>
</div>
<div class="section" id="difference-of-gaussians-filter">
<h4>Difference of Gaussians filter:<a class="headerlink" href="#difference-of-gaussians-filter" title="Permalink to this headline">¶</a></h4>
<p>This is an optional filter to improve the contrast of objects. This filter has a &#8220;Mexican Hat&#8221; shape that weighs negatively the intensity at the border of the objects. The main parameter to set here is the <code class="docutils literal"><span class="pre">size</span></code>, as an (x,y,z) tuple, for instance <code class="docutils literal"><span class="pre">(6,6,11)</span></code> would work well for our example. However, we’ll bypass this filter and set it to <code class="docutils literal"><span class="pre">None</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">filterDoGParameter</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s">&quot;size&quot;</span>    <span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s">&quot;sigma&quot;</span>   <span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s">&quot;sigma2&quot;</span>  <span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s">&quot;save&quot;</span>    <span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s">&quot;verbose&quot;</span> <span class="p">:</span> <span class="bp">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">}</span>
</pre></div>
</div>
<p>For this tutorial, we will not use the DoG filter, as it is unnecessary. The signal from a c-Fos nuclear staining has enough contrast and a simple shape that do not necessitate this additionnal filtering, but it could help increase the contrast of the relevant objects for other experiments.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As for the background subtraction seen above, you can save the output of the filter to files in a folder. This is important in order to check that the settings you used are effective!</p>
</div>
</div>
<div class="section" id="extended-maxima">
<h4>Extended Maxima:<a class="headerlink" href="#extended-maxima" title="Permalink to this headline">¶</a></h4>
<p>The extended maxima is another filter to use for objects that contain several peaks of intensity, like for instance a higher resolution view of a cell nucleus where you might have a more granular texture. In the case of our tutorial, the c-fos nuclear signal is imaged at low resolution, so the object only appears as a single peak, so we will turn off the extended maxima by setting the <code class="docutils literal"><span class="pre">hMax</span></code> parameter to <code class="docutils literal"><span class="pre">None</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">findExtendedMaximaParameter</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s">&quot;hMax&quot;</span>      <span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s">&quot;size&quot;</span>      <span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s">&quot;threshold&quot;</span> <span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s">&quot;save&quot;</span>      <span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s">&quot;verbose&quot;</span>   <span class="p">:</span> <span class="bp">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Saving the files for the output of this filter as explained above would overlay in red the extended maxima found on top of the DoG filtered image (we recommend using also DoG if you use the Extended Maxima).</p>
</div>
</div>
<div class="section" id="peak-intensity">
<h4>Peak Intensity:<a class="headerlink" href="#peak-intensity" title="Permalink to this headline">¶</a></h4>
<p>By default, the code will look for the center of the 3D shape painted by the Extended Maxima and attribute the x,y,z to this coordinate. This is the coordinate that will be saved in the point file. However, we noticed that often, the pixel that contains the highest intensity (the peak) is not always the center of the volume. This is likely due to potential deformations of the shape of the nucleus by the objective lens. To look for the actual peak intensity for the detected object, we’ll use this function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">findIntensityParameter</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s">&quot;method&quot;</span> <span class="p">:</span> <span class="s">&#39;Max&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s">&quot;size&quot;</span>   <span class="p">:</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">}</span>
</pre></div>
</div>
<p>If the parameter <code class="docutils literal"><span class="pre">method</span></code> is set to <code class="docutils literal"><span class="pre">None</span></code>, then the peak intensity will be also the pixel at the center of the volume. We’ll set the parameter to <code class="docutils literal"><span class="pre">Max</span></code> to look if there is a voxel around the center that has a higher intensity than the center. This will be done by looking around the center with a box of a certain <code class="docutils literal"><span class="pre">size</span></code>, that we set here to (3,3,3), which indicates by how many pixels in each direction from the center the code will be looking for a peak of higher intensity.</p>
</div>
<div class="section" id="cell-volume">
<h4>Cell Volume:<a class="headerlink" href="#cell-volume" title="Permalink to this headline">¶</a></h4>
<p>The cell shape is not used for the cell detection itself (which is just searching for local maxima in intensity), but measuring the cell volume will be important to later remove the local peaks detected that do not correspond to an actual cell. This is done by setting these parameters:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">detectCellShapeParameter</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s">&quot;threshold&quot;</span> <span class="p">:</span> <span class="mi">700</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s">&quot;save&quot;</span>      <span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s">&quot;verbose&quot;</span>   <span class="p">:</span> <span class="bp">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">}</span>
</pre></div>
</div>
<p>The shape detection is done by a watershed, which will paint the volume of the cell from the detected center outwards. The only parameter to set is the <code class="docutils literal"><span class="pre">threshold</span></code>. The threshold corresponds to the background intensity, and tells the watershed detection where to stop painting. This value is based on the background subtracted image here. If the <code class="docutils literal"><span class="pre">threshold</span></code> is set to <code class="docutils literal"><span class="pre">None</span></code>, then the cell shape detection is bypassed.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Saving the files for the output of this filter as explained above would show all detected objects. The most convenient is to open the folder of images generated with ImageJ, and apply a LUT (Lookup Table) to color each object differently, for instance using the LUT 3-3-2 RGB. The code will write on the image each detected object with a increasing intensity value, so you can make sure this way that adjacent cells are not blending together.</p>
</div>
</div>
</div>
<div class="section" id="heat-map-generation">
<h3><cite>Heat map generation</cite><a class="headerlink" href="#heat-map-generation" title="Permalink to this headline">¶</a></h3>
<p>The voxelization makes it easier to look at the results of the cell detection. The voxelization function will create an image of a specified size (usually the size of the Atlas file) and plot the detected cell centers. To make them visible easily, each point will be expanded into a sphere (or cube, or gaussian) of a given diameter. The intensity value of this sphere is set to 1 by default. So if many points are detected, the overlapping spheres will create a high intensity region.</p>
<p>To set the output for the voxelized heat map file (you would usually not change this):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">VoxelizationFile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">BaseDirectory</span><span class="p">,</span> <span class="s">&#39;points_voxelized.tif&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>And then let’s survey the parameters for the voxelization:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">voxelizeParameter</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s">&quot;method&quot;</span> <span class="p">:</span> <span class="s">&#39;Spherical&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s">&quot;size&quot;</span> <span class="p">:</span> <span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">15</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s">&quot;weights&quot;</span> <span class="p">:</span> <span class="bp">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">};</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">method</span></code> here is set to <code class="docutils literal"><span class="pre">Spherical</span></code> to paint the points as expanded spheres. the <code class="docutils literal"><span class="pre">size</span></code> of those spheres is set next, and is given in pixels. Here, we’ll choose <code class="docutils literal"><span class="pre">(15,15,15)</span></code>, but feel free to experiment! Note that the size is in pixels in the final resolution. So for instance, here each sphere will have a diameter of 15 x 25 = 375µm. The <code class="docutils literal"><span class="pre">weights</span></code> parameter will be changed later, but is set to <code class="docutils literal"><span class="pre">None</span></code> at this point, meaning that each sphere has an intensity value of 1. The weights allows to change this by integrating the size or intensity of the cells when drawing each sphere.</p>
</div>
<div class="section" id="config-parameters">
<h3><cite>Config parameters</cite><a class="headerlink" href="#config-parameters" title="Permalink to this headline">¶</a></h3>
<p>There are two configuration parameter you should change to match the processing power of your workstation. The first one is the number of processors to be used for the resampling/rotation operations. As this process is not very demanding for the memory, just use the max number of parallel processes your configuration can handle. For instance, we have a 6 cores machine:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ResamplingParameter</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;processes&quot;</span><span class="p">:</span> <span class="mi">12</span><span class="p">};</span>
</pre></div>
</div>
<p>The next settings are for the cell detection. This is limited mainly by the amount of RAM memory you have, but will also change depending on how many filters you use, and their settings. Here is the setting we use on our machine, with 128Gb of RAM for this tutorial:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">StackProcessingParameter</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s">&quot;processes&quot;</span> <span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s">&quot;chunkSizeMax&quot;</span> <span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s">&quot;chunkSizeMin&quot;</span> <span class="p">:</span> <span class="mi">50</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s">&quot;chunkOverlap&quot;</span> <span class="p">:</span> <span class="mi">16</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s">&quot;chunkOptimization&quot;</span> <span class="p">:</span> <span class="bp">True</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s">&quot;chunkOptimizationSize&quot;</span> <span class="p">:</span> <span class="nb">all</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s">&quot;processMethod&quot;</span> <span class="p">:</span> <span class="s">&quot;parallel&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">};</span>
</pre></div>
</div>
<p>For the cell detection, the full stack of images will be sliced in smaller chunks to be processed in parallel, and then fused back together. Although it would be tempting to use all the available parallel processing power from your machine, each chunk will take a significant amount of RAM while being analyzed, so the more chunks you process in parallel, the smaller they will be. Also, the chunks will need to overlap, so the smaller they are, the higher the number of overlaps. The size of a chunk is set by both <code class="docutils literal"><span class="pre">chunkSizeMax</span></code> and <code class="docutils literal"><span class="pre">chunkSizeMin</span></code>. This is because the code will determine what is the ideal chunk size within that range, depending on the total number of chunks to process. When running the script, keep an eye on the amount of memory used by using the system’s activity monitor for instance. If too much data has to go in the swap memory (meaning the RAM is maxed out), reduce the chunk size, or reduce the number of parallel processes.</p>
</div>
<div class="section" id="run-parameters">
<h3><cite>Run Parameters</cite><a class="headerlink" href="#run-parameters" title="Permalink to this headline">¶</a></h3>
<p>You usually would not change anything in this section of the parameter file. This section defines the name of the files generated during the run, and set the parameters for the various operations of resampling and alignment. Of note, you can check these parameters for the alignment:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">RegistrationAlignmentParameter</span><span class="p">[</span><span class="s">&quot;affineParameterFile&quot;</span><span class="p">]</span> <span class="o">=</span> \
<span class="gp">&gt;&gt;&gt; </span>                <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">PathReg</span><span class="p">,</span> <span class="s">&#39;Par0000affine.txt&#39;</span><span class="p">);</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">RegistrationAlignmentParameter</span><span class="p">[</span><span class="s">&quot;bSplineParameterFile&quot;</span><span class="p">]</span> <span class="o">=</span> \
<span class="gp">&gt;&gt;&gt; </span>                <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">PathReg</span><span class="p">,</span> <span class="s">&#39;Par0000bspline.txt&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>These point to the two files that will be used as parameter files for the alignment operation with Elastix. If you create new parameter files for the alignment based on your specific need, just make sure you link to the correct parameter file here.</p>
<p>We’re all set for the parameter file, now let’s explain how the run will proceed.</p>
</div>
</div>
<div class="section" id="the-run-file">
<h2>The Run File<a class="headerlink" href="#the-run-file" title="Permalink to this headline">¶</a></h2>
<p>The run file consist of the list of operation to execute to analyze each sample. For our tutorial, it can be found in /ClearMap/Scripts/process_template.py. The run file starts by loading all the parameters from the parameter file:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">execfile</span><span class="p">(</span><span class="s">&#39;./ClearMap/Scripts/parameter_file_template.py&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Make sure all the modules load correctly. Otherwise, try to install the missing modules. You might get a warning from the compiler the first time you load to parameter file on a new installation. The script shown in the tutorial will execute the following operations:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#resampling-operations">Resampling operations</a></li>
<li><a class="reference internal" href="#alignment-operations">Alignment operations</a></li>
<li><a class="reference internal" href="#cell-detection-and-thresholding">Cell detection and thresholding</a></li>
<li><a class="reference internal" href="#point-coordinate-transformation">Point coordinate transformation</a></li>
<li><a class="reference internal" href="#heat-map">Heat map</a></li>
<li><a class="reference internal" href="#table-generation">Table generation</a></li>
</ul>
</div></blockquote>
<div class="section" id="resampling-operations">
<h3><cite>Resampling operations</cite><a class="headerlink" href="#resampling-operations" title="Permalink to this headline">¶</a></h3>
<p>The first set of operations to run are the resampling, which will use the parameters set previously. The resampling is executed by the <code class="docutils literal"><span class="pre">resampleData</span></code> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">resampleData</span><span class="p">(</span><span class="o">**</span><span class="n">CorrectionResamplingParameterCfos</span><span class="p">);</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">resampleData</span><span class="p">(</span><span class="o">**</span><span class="n">CorrectionResamplingParameterAutoFluo</span><span class="p">);</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">resampleData</span><span class="p">(</span><span class="o">**</span><span class="n">RegistrationResamplingParameter</span><span class="p">);</span>
</pre></div>
</div>
<p>As you can notice, there are 3 sets of resampling operations. The first two are optional. They create files of intermediate size for the c-Fos and Autofluorescence channels to correct for eventual movements of the sample between the acquisition of those channels. The third resampling only concerns the auto-fluorescence channel and will generate the file used to align to the Atlas reference.</p>
</div>
<div class="section" id="alignment-operations">
<h3><cite>Alignment operations</cite><a class="headerlink" href="#alignment-operations" title="Permalink to this headline">¶</a></h3>
<p>The alignment is done via Elastix, which is interfaced by ClearMap and is executed by the <code class="docutils literal"><span class="pre">alignData</span></code> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">resultDirectory</span>  <span class="o">=</span> <span class="n">alignData</span><span class="p">(</span><span class="o">**</span><span class="n">CorrectionAlignmentParameter</span><span class="p">);</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">resultDirectory</span>  <span class="o">=</span> <span class="n">alignData</span><span class="p">(</span><span class="o">**</span><span class="n">RegistrationAlignmentParameter</span><span class="p">);</span>
</pre></div>
</div>
<p>We again do two sets of alignments. The first one here is optional, and is using the files of intermediate resolution generated by the first two resampling operations to re-align the 2 channels in case the sample moved between acquisitions. The second alignment is done onto the Atlas.</p>
</div>
<div class="section" id="cell-detection-and-thresholding">
<h3><cite>Cell detection and thresholding</cite><a class="headerlink" href="#cell-detection-and-thresholding" title="Permalink to this headline">¶</a></h3>
<p>The cell detection is started by this command:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">detectCells</span><span class="p">(</span><span class="o">**</span><span class="n">ImageProcessingParameter</span><span class="p">);</span>
</pre></div>
</div>
<p>This should take a while, between 20 minutes to a few hours depending on your machine, the size of the stack, the filter used. If you&#8217;re executing the cell detection for testing the parameter, consider restricting the range of the detection as described above with the <code class="docutils literal"><span class="pre">cFosFileRange</span></code> parameter.</p>
<p>The cell detection will create two files here: <code class="docutils literal"><span class="pre">cells-allpoints.npy</span></code> and <code class="docutils literal"><span class="pre">intensities-allpoints.npy</span></code>. These two files will contain all the detected maxima, and need to be filtered, as most local peaks do not correspond to an actual cell.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The coordinates in the files are in the original coordinates of the raw data, and are not transposed yet.</p>
</div>
<p>Once the cell detection is done, the points detected have to be filtered to retain only the genuine cells. This is the most important step of the cell detection. First, let&#8217;s open the files <code class="docutils literal"><span class="pre">cells-allpoints.npy</span></code> and <code class="docutils literal"><span class="pre">intensities-allpoints.npy</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">points</span><span class="p">,</span> <span class="n">intensities</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">readPoints</span><span class="p">(</span><span class="n">ImageProcessingParameter</span><span class="p">[</span><span class="s">&quot;sink&quot;</span><span class="p">]);</span>
</pre></div>
</div>
<p>Here, we use the function io.readPoints which opens the data related to points coordinates or intensities. In ClearMap scripts, the inputs are usually referred to as <code class="docutils literal"><span class="pre">source</span></code> and the output as <code class="docutils literal"><span class="pre">sink</span></code>. <code class="docutils literal"><span class="pre">ImageProcessingParameter[&quot;sink&quot;]</span></code> is defined in the parameter file described above, and is a tuple containing the location of both files for point coordinates and intensities. So here we&#8217;re opening both files at the same time.</p>
<p>Then, we use the function <code class="docutils literal"><span class="pre">thresholdPoints</span></code> to threshold the points based on their size and save them to 2 files (coordinates and intensities):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">points</span><span class="p">,</span> <span class="n">intensities</span> <span class="o">=</span> <span class="n">thresholdPoints</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">intensities</span><span class="p">,</span> \
<span class="gp">&gt;&gt;&gt; </span>                             <span class="n">threshold</span> <span class="o">=</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">900</span><span class="p">),</span> <span class="n">row</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">));</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">writePoints</span><span class="p">(</span><span class="n">FilteredCellsFile</span><span class="p">,</span> <span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">intensities</span><span class="p">));</span>
</pre></div>
</div>
<p>The way the <code class="docutils literal"><span class="pre">thresholdPoints</span></code> function work is by setting the <code class="docutils literal"><span class="pre">threshold</span></code> parameter as <code class="docutils literal"><span class="pre">(lower</span> <span class="pre">limit,</span> <span class="pre">upper</span> <span class="pre">limit)</span></code>. If only one value is provided, it assumes this is the lower boundary. <code class="docutils literal"><span class="pre">row</span></code> defines for the (lower, higher) boundaries which column to use from the intensities array. We presented this array in the overview, but as a reminder:</p>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="92%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Row</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>Max intensity of the cell center in the raw data</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>Max intensity of the cell center after the DoG filtering.</td>
</tr>
<tr class="row-even"><td>2</td>
<td>Max intensity of the cell center after the background subtraction</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>Cell size in voxels after the watershed detection</td>
</tr>
</tbody>
</table>
<p>So here we use column 3 for both boundaries, which is the volume in voxel of each detected cell, which we set at 20.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">the size in voxels of each detected cell is defined by the watershed, which will greatly depend on the <code class="docutils literal"><span class="pre">threshold</span></code> parameter set previously for the cell detection, so if you change this parameter, you&#8217;ll have to adjust threshold here as well.</p>
</div>
<p>Finally, you can now check that the cell detection worked as expected by plotting the result of the detection and thresholding onto the raw data. This should be disabled if you&#8217;re running the detection on the whole stack, and should only be used while testing. Just delete or comment out (with #) if you don&#8217;t need it. To run the cell detection check:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">iDISCO.Visualization.Plot</span> <span class="kn">as</span> <span class="nn">plt</span><span class="p">;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pointSource</span><span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">BaseDirectory</span><span class="p">,</span> <span class="n">FilteredCellsFile</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">overlayPoints</span><span class="p">(</span><span class="n">cFosFile</span><span class="p">,</span> <span class="n">pointSource</span><span class="p">,</span> <span class="n">pointColor</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">cFosFileRange</span><span class="p">);</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">writeData</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">BaseDirectory</span><span class="p">,</span> <span class="s">&#39;cells_check.tif&#39;</span><span class="p">),</span> <span class="n">data</span><span class="p">);</span>
</pre></div>
</div>
<p>You might get a warning that a non-standard tiff file is being written. ImageJ, with the plugin BioFormat, can open these files. The resulting <code class="docutils literal"><span class="pre">cell_check.tif</span></code> file has 2 channels, one with the original data and one with the detected cells shown as a single pixel pointing to the detected center. Browse through the stack to make sure there is only one center detected per cell, that there are no obvious false positive or false negatives.</p>
</div>
<div class="section" id="point-coordinate-transformation">
<h3><cite>Point coordinate transformation</cite><a class="headerlink" href="#point-coordinate-transformation" title="Permalink to this headline">¶</a></h3>
<p>The points coordinate are then resampled and transformed onto their final position in the Atlas reference space. Again, this is done twice: once for the correction between both channels, and then for the Atlas alignment.</p>
<dl class="docutils">
<dt>The first step: correction (optional)</dt>
<dd><div class="first last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">points</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">readPoints</span><span class="p">(</span><span class="n">CorrectionResamplingPointsParameter</span><span class="p">[</span><span class="s">&quot;pointSource&quot;</span><span class="p">]);</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">points</span> <span class="o">=</span> <span class="n">resamplePoints</span><span class="p">(</span><span class="o">**</span><span class="n">CorrectionResamplingPointsParameter</span><span class="p">);</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">points</span> <span class="o">=</span> <span class="n">transformPoints</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> \
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">transformDirectory</span> <span class="o">=</span> <span class="n">CorrectionAlignmentParameter</span><span class="p">[</span><span class="s">&quot;resultDirectory&quot;</span><span class="p">],</span> \
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">indices</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span> <span class="n">resultDirectory</span> <span class="o">=</span> <span class="bp">None</span><span class="p">);</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">CorrectionResamplingPointsInverseParameter</span><span class="p">[</span><span class="s">&quot;pointSource&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">points</span><span class="p">;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">points</span> <span class="o">=</span> <span class="n">resamplePointsInverse</span><span class="p">(</span><span class="o">**</span><span class="n">CorrectionResamplingPointsInverseParameter</span><span class="p">);</span>
</pre></div>
</div>
</dd>
</dl>
<p>The points are first resampled with the function <code class="docutils literal"><span class="pre">resamplePoints</span></code> and then their coordinates are transformed based on the results of the alignment done by Elastix with the <code class="docutils literal"><span class="pre">transformPoints</span></code> function. This function works by interfacing with the Transformix mode of Elastix. The parameter <code class="docutils literal"><span class="pre">indices</span></code>, here set to <code class="docutils literal"><span class="pre">False</span></code> indicate to keep the point coordinates with the decimals after the resampling, instead of using the integer coordinates, so prevent loosing information while sequentially re-sampling the point coordinates.</p>
<dl class="docutils">
<dt>The second step: alignment of the points in the Atlas reference space</dt>
<dd><div class="first last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">RegistrationResamplingPointParameter</span><span class="p">[</span><span class="s">&quot;pointSource&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">points</span><span class="p">;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">points</span> <span class="o">=</span> <span class="n">resamplePoints</span><span class="p">(</span><span class="o">**</span><span class="n">RegistrationResamplingPointParameter</span><span class="p">);</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">points</span> <span class="o">=</span> <span class="n">transformPoints</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> \
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">transformDirectory</span> <span class="o">=</span> <span class="n">RegistrationAlignmentParameter</span><span class="p">[</span><span class="s">&quot;resultDirectory&quot;</span><span class="p">],</span>\
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">indices</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span> <span class="n">resultDirectory</span> <span class="o">=</span> <span class="bp">None</span><span class="p">);</span>
</pre></div>
</div>
</dd>
<dt>Then writing the final point coordinates:</dt>
<dd><div class="first last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">writePoints</span><span class="p">(</span><span class="n">TransformedCellsFile</span><span class="p">,</span> <span class="n">points</span><span class="p">);</span>
</pre></div>
</div>
</dd>
</dl>
<p>The points in their Atlas coordinates are written in the file <code class="docutils literal"><span class="pre">cells_transformed_to_Atlas.npy</span></code> and will be used for the region statistics and to generate the heat maps.</p>
</div>
<div class="section" id="heat-map">
<h3><cite>Heat map</cite><a class="headerlink" href="#heat-map" title="Permalink to this headline">¶</a></h3>
<p>First, let&#8217;s open the files generated previously:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">points</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">readPoints</span><span class="p">(</span><span class="n">TransformedCellsFile</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">intensities</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">readPoints</span><span class="p">(</span><span class="n">FilteredCellsFile</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>Then, the heat map is generated by the <code class="docutils literal"><span class="pre">voxelize</span></code> command:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">vox</span> <span class="o">=</span> <span class="n">voxelize</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">AtlasFile</span><span class="p">,</span> <span class="o">**</span><span class="n">voxelizeParameter</span><span class="p">);</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">writeData</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">BaseDirectory</span><span class="p">,</span> <span class="s">&#39;cells_heatmap.tif&#39;</span><span class="p">),</span> <span class="n">vox</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s">&#39;int32&#39;</span><span class="p">));</span>
</pre></div>
</div>
<p>The heat map is generated as a 32bit float file, so it may need to be down sampled in ImageJ. The second parameter, <code class="docutils literal"><span class="pre">AtlasFile</span></code>, is only to pass the size of the Atlas file to the function.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The heat map generated here will be used later for the voxel statistics.</p>
</div>
</div>
<div class="section" id="table-generation">
<h3><cite>Table generation</cite><a class="headerlink" href="#table-generation" title="Permalink to this headline">¶</a></h3>
<p>The table will show the number of detected points according to the region annotations. It relies on having a labeled image, which is a nrrd or tif file. The function <code class="docutils literal"><span class="pre">countPointsInRegions</span></code> will use the intensity value of each point as defining the regions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ids</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">countPointsInRegions</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">labeledImage</span> <span class="o">=</span> <span class="n">AnnotationFile</span><span class="p">,</span> \
<span class="gp">&gt;&gt;&gt; </span>                                   <span class="n">intensities</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">collapse</span> <span class="o">=</span> <span class="bp">None</span><span class="p">);</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">AnnotationFile</span></code> is set in the parameter file as shown above, and should match the dimensions and orientation of the Atlas file used. The <code class="docutils literal"><span class="pre">collapse</span></code> function is here set to <code class="docutils literal"><span class="pre">None</span></code>, but is used if you wish to group adjacent regions into larger regions if you feel that the AnnotationFile has too many subdivisions.</p>
<p>Then, a table of the results is generated:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">table</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ids</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> \
<span class="gp">&gt;&gt;&gt; </span>                 <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s">&#39;id&#39;</span><span class="p">,</span><span class="s">&#39;int64&#39;</span><span class="p">),(</span><span class="s">&#39;counts&#39;</span><span class="p">,</span><span class="s">&#39;f8&#39;</span><span class="p">),(</span><span class="s">&#39;name&#39;</span><span class="p">,</span> <span class="s">&#39;a256&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">table</span><span class="p">[</span><span class="s">&quot;id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ids</span><span class="p">;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">table</span><span class="p">[</span><span class="s">&quot;counts&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">counts</span><span class="p">;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">table</span><span class="p">[</span><span class="s">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">labelToName</span><span class="p">(</span><span class="n">ids</span><span class="p">);</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">writeTable</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">BaseDirectory</span><span class="p">,</span> <span class="s">&#39;Annotated_counts.csv&#39;</span><span class="p">),</span> <span class="n">table</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Contrary to the heat maps, the table generated here will not be used for the statistics later, so it is not necessary to execute this in most cases.</p>
</div>
<p>This concludes the part of the tutorial covering the settings and run parameters used to analyze the c-Fos dataset in the mouse brain. The next section will cover how to run the statistics on the results obtained after running the <code class="docutils literal"><span class="pre">process_template.py</span></code> script for all samples of the same experiment.</p>
</div>
</div>
<div class="section" id="analysis-tools">
<h2>Analysis Tools<a class="headerlink" href="#analysis-tools" title="Permalink to this headline">¶</a></h2>
<p>ClearMap provides different ways to analyze the results of the cell detection. In this tutorial, we will examine how to compare the c-Fos cell distribution in 2 groups of 4 brains each analyzed with the scripts shown above. The statistics package covers two sorts of statistical analysis:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#voxel-statistics">Voxel statistics</a>: these are based on the heat map generated as above</li>
<li><a class="reference internal" href="#regions-statistics">Regions statistics</a>: these are using the annotation files to segment the detected cells into anatomical regions</li>
<li><a class="reference internal" href="#automated-region-isolation">Automated region isolation</a>: to visualize in 3D specific regions from the heat maps</li>
</ul>
</div></blockquote>
<p>In this example, we will compare a group of control mice injected with a saline solution against mice injected with Haloperidol, which is a psycho-active drug.</p>
<div class="section" id="voxel-statistics">
<h3><cite>Voxel statistics</cite><a class="headerlink" href="#voxel-statistics" title="Permalink to this headline">¶</a></h3>
<p>First, let&#8217;s import the modules necessary to run the statistics, and set the working directory:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ClearMap.Analysis.Statistics</span> <span class="kn">as</span> <span class="nn">stat</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">iDISCO.Analysis.Tools.MultipleComparisonCorrection</span> <span class="kn">as</span> <span class="nn">mc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ClearMap.Analysis.Label</span> <span class="kn">as</span> <span class="nn">lbl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ClearMap.IO.IO</span> <span class="kn">as</span> <span class="nn">io</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span><span class="o">,</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">baseDirectory</span> <span class="o">=</span> <span class="s">&#39;/home/mtllab/Documents/pharmaco/&#39;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Here we set the working directory to the folder containing all the samples for this experiment, while we were working inside the folders of individual samples previously.</p>
</div>
<p>Then, let&#8217;s load the heat map image stacks from each sample into two groups:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">group1</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;/home/mtllab/Documents/pharmaco/sample1/cells_heatmap.tif&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>          <span class="s">&#39;/home/mtllab/Documents/pharmaco/sample2/cells_heatmap.tif&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>          <span class="s">&#39;/home/mtllab/Documents/pharmaco/sample3/cells_heatmap.tif&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>          <span class="s">&#39;/home/mtllab/Documents/pharmaco/sample4/cells_heatmap.tif&#39;</span>
<span class="gp">&gt;&gt;&gt; </span>          <span class="p">];</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">group2</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;/home/mtllab/Documents/pharmaco/sample5/cells_heatmap.tif&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>          <span class="s">&#39;/home/mtllab/Documents/pharmaco/sample6/cells_heatmap.tif&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>          <span class="s">&#39;/home/mtllab/Documents/pharmaco/sample7/cells_heatmap.tif&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>          <span class="s">&#39;/home/mtllab/Documents/pharmaco/sample8/cells_heatmap.tif&#39;</span>
<span class="gp">&gt;&gt;&gt; </span>          <span class="p">];</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g1</span> <span class="o">=</span> <span class="n">stat</span><span class="o">.</span><span class="n">readDataGroup</span><span class="p">(</span><span class="n">group1</span><span class="p">);</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g2</span> <span class="o">=</span> <span class="n">stat</span><span class="o">.</span><span class="n">readDataGroup</span><span class="p">(</span><span class="n">group2</span><span class="p">);</span>
</pre></div>
</div>
<p>We can then generate average heat maps for each group, as well as standard deviation maps:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g1m</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">g1</span><span class="p">,</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">writeData</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">baseDirectory</span><span class="p">,</span> <span class="s">&#39;saline_mean.mhd&#39;</span><span class="p">),</span> \
<span class="gp">&gt;&gt;&gt; </span>                                         <span class="n">io</span><span class="o">.</span><span class="n">sagittalToCoronalData</span><span class="p">(</span><span class="n">g1m</span><span class="p">));</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g1s</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">g1</span><span class="p">,</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">writeData</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">baseDirectory</span><span class="p">,</span> <span class="s">&#39;saline_std.mhd&#39;</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>                                         <span class="n">io</span><span class="o">.</span><span class="n">sagittalToCoronalData</span><span class="p">(</span><span class="n">g1s</span><span class="p">));</span>
</pre></div>
</div>
<p>The same thing will be done for group 2. Instead of writing directly the result as an image (here we wrote the file as a raw <code class="docutils literal"><span class="pre">.mhd</span></code> file), we used the function <code class="docutils literal"><span class="pre">io.sagittalToCoronalData</span></code> which is a convenient way to reorient the data in coronal plane, which is a more usual way to look at anatomical data (the scans and atlases are in sagittal orientation originally). Open the <code class="docutils literal"><span class="pre">.mhd</span></code> files in ImageJ. Don&#8217;t forget that the <code class="docutils literal"><span class="pre">.mhd</span></code> file is just the header, and that the actual image comes in the companion <code class="docutils literal"><span class="pre">.raw</span></code> file.</p>
<p>We can now generate the <em>p</em> values map:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pvals</span><span class="p">,</span> <span class="n">psign</span> <span class="o">=</span> <span class="n">stat</span><span class="o">.</span><span class="n">tTestVoxelization</span><span class="p">(</span><span class="n">g1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s">&#39;float&#39;</span><span class="p">),</span> <span class="n">g2</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s">&#39;float&#39;</span><span class="p">),</span>\
<span class="gp">&gt;&gt;&gt; </span>                                      <span class="n">signed</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> <span class="n">pcutoff</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">);</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pvalscolor</span> <span class="o">=</span> <span class="n">stat</span><span class="o">.</span><span class="n">colorPValues</span><span class="p">(</span><span class="n">pvals</span><span class="p">,</span> <span class="n">psign</span><span class="p">,</span> <span class="n">positive</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">negative</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]);</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">writeData</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">baseDirectory</span><span class="p">,</span> <span class="s">&#39;pvalues.tif&#39;</span><span class="p">),</span> \
<span class="gp">&gt;&gt;&gt; </span>             <span class="n">io</span><span class="o">.</span><span class="n">sagittalToCoronalData</span><span class="p">(</span><span class="n">pvalscolor</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s">&#39;float32&#39;</span><span class="p">)));</span>
</pre></div>
</div>
<p>We used here a cutoff of 5%. The first function <code class="docutils literal"><span class="pre">stat.tTestVoxelization</span></code> generates the <em>p</em> values using a T test with the unequal variance hypothesis set by default. The
<code class="docutils literal"><span class="pre">stat.colorPValues</span></code> function will attribute a color to each pixel of the <em>p</em> value map depending on whether the difference of the means between group1 and group2 is significantly positive or negative. You may get a warning that a non-standard tiff file is being written. You may also get warnings from the statistics library during the test calculation, just ignore them.</p>
<p>You have now generated 5 image stacks: 2 average heat maps, 2 standard deviation maps (one for each group) and 1 <em>p</em> values map.</p>
</div>
<div class="section" id="regions-statistics">
<h3><cite>Regions statistics</cite><a class="headerlink" href="#regions-statistics" title="Permalink to this headline">¶</a></h3>
<p>The region statistics use an annotation image file that defines the anatomical regions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ABAlabeledImage</span> <span class="o">=</span> <span class="s">&#39;/home/mtllab/atlas/annotation_25_right.tif&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>For the region statistics, we will load the point coordinates instead. We&#8217;ll use the file that contains the coordinates transformed to the Atlas:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">group1</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;/home/mtllab/Documents/pharmaco/sample1/cells_transformed_to_Atlas.npy&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>          <span class="s">&#39;/home/mtllab/Documents/pharmaco/sample2/cells_transformed_to_Atlas.npy&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>          <span class="s">&#39;/home/mtllab/Documents/pharmaco/sample3/cells_transformed_to_Atlas.npy&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>          <span class="s">&#39;/home/mtllab/Documents/pharmaco/sample4/cells_transformed_to_Atlas.npy&#39;</span>
<span class="gp">&gt;&gt;&gt; </span>          <span class="p">];</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">group2</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;/home/mtllab/Documents/pharmaco/sample5/cells_transformed_to_Atlas.npy&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>          <span class="s">&#39;/home/mtllab/Documents/pharmaco/sample6/cells_transformed_to_Atlas.npy&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>          <span class="s">&#39;/home/mtllab/Documents/pharmaco/sample7/cells_transformed_to_Atlas.npy&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>          <span class="s">&#39;/home/mtllab/Documents/pharmaco/sample8/cells_transformed_to_Atlas.npy&#39;</span>
<span class="gp">&gt;&gt;&gt; </span>          <span class="p">];</span>
</pre></div>
</div>
<p>Then we&#8217;ll count the number of cells per region for each group:</p>
<p>ids, counts1 = stat.countPointsGroupInRegions(group1, intensityGroup = None, returnIds = True, labeledImage = ABAlabeledImage, returnCounts = True, collapse = None);
counts2 = stat.countPointsGroupInRegions(group2, intensityGroup = None, returnIds = False, labeledImage = ABAlabeledImage, returnCounts = True, collapse = None);</p>
<p>The function <code class="docutils literal"><span class="pre">stat.countPointsGroupInRegions</span></code> can return 1, 2 or 3 results depending on the parameters set:</p>
<table border="1" class="docutils">
<colgroup>
<col width="9%" />
<col width="91%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>intensityGroup</td>
<td>You can, on top of a cell coordinate group, create groups containing the intensity data, to include the intensity information in the statistics</td>
</tr>
<tr class="row-odd"><td>returnIds</td>
<td>To set the function to return the region identity found in the labeled file. You only have to do it for one of the two groups</td>
</tr>
<tr class="row-even"><td>collapse</td>
<td>You can set regions to be fused into larger regions from the table file containing the region names and hierarchy</td>
</tr>
</tbody>
</table>
<p>Then you can calculate the <em>p</em> values for the significance of the difference of the mean for each region. Those tests are independent:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pvals</span><span class="p">,</span> <span class="n">psign</span> <span class="o">=</span> <span class="n">stat</span><span class="o">.</span><span class="n">tTestPointsInRegions</span><span class="p">(</span><span class="n">counts1</span><span class="p">,</span> <span class="n">counts2</span><span class="p">,</span> <span class="n">pcutoff</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> \
<span class="gp">&gt;&gt;&gt; </span>                                         <span class="n">signed</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> <span class="n">equal_var</span> <span class="o">=</span> <span class="bp">False</span><span class="p">);</span>
</pre></div>
</div>
<p>Optionally, you can also attribute a &#8220;q&#8221; value to the <em>p</em> values, to estimate the false discovery rate, as we&#8217;re performing a lot of tests:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">qvals</span> <span class="o">=</span> <span class="n">mc</span><span class="o">.</span><span class="n">estimateQValues</span><span class="p">(</span><span class="n">pvals</span><span class="p">);</span>
</pre></div>
</div>
<p>And then you can generate a table containing those results (see the included script file for generating the table).</p>
</div>
<div class="section" id="automated-region-isolation">
<h3><cite>Automated region isolation</cite><a class="headerlink" href="#automated-region-isolation" title="Permalink to this headline">¶</a></h3>
<p>You can also apply the Annotation file to the heat maps instead of the detected cells. This will generate 3D crops of the heat maps to only show specific regions according to the annotation file. Start by importing the modules as shown above, as well as setting the annotation file you wish to use as shown previously. We&#8217;ll generate then a variable containing the list of all the labels IDs present in the annotation file:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">label</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">readData</span><span class="p">(</span><span class="n">annotationFile</span><span class="p">);</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s">&#39;int32&#39;</span><span class="p">);</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labelids</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">label</span><span class="p">);</span>
</pre></div>
</div>
<p>Then, we&#8217;ll create a map, <code class="docutils literal"><span class="pre">outside</span></code> of everything we want to exclude. For example, to exclude every structure of the brain except the cortex, let&#8217;s do:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">labelids</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>   <span class="k">if</span> <span class="ow">not</span> <span class="n">lbl</span><span class="o">.</span><span class="n">labelAtLevel</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">688</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>       <span class="n">outside</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">outside</span><span class="p">,</span> <span class="n">label</span> <span class="o">==</span> <span class="n">l</span><span class="p">);</span>
</pre></div>
</div>
<p>Here, we&#8217;re using the function <code class="docutils literal"><span class="pre">lbl.labelAtLevel</span></code> which returns the identity of the parent of a region at a given level of hierarchy. The regions IDs are annotated in a table in ClearMap with for each region of the brain the identity of its parent region containing it. For instance, the layer 4 of the barrel cortex is 8 levels deep in the hierarchy and has the ID 1047, and is contained in the barrel cortex (329) which is itself in the cortex (688). <code class="docutils literal"><span class="pre">lbl.labelAtLevel(x,</span> <span class="pre">n)</span></code> will return the ID of the region at the level <code class="docutils literal"><span class="pre">n</span></code> containing the region <code class="docutils literal"><span class="pre">x</span></code>. So if <code class="docutils literal"><span class="pre">x</span></code> is 5 levels deep in the hierarchy of all regions, then when <code class="docutils literal"><span class="pre">n</span></code> is larger than 5, the function will return <code class="docutils literal"><span class="pre">x</span></code>. Otherwise, if <code class="docutils literal"><span class="pre">n</span></code> is smaller than 5, it returns the ID of the region of level <code class="docutils literal"><span class="pre">n</span></code> containing <code class="docutils literal"><span class="pre">x</span></code>.</p>
<p>So now, the variable outside contains a boolean array for each voxel (True or False) whether that voxel belongs to the cortex or not in the reference space (True means it is not cortex). Let&#8217;s then open our average heat map:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">heatmap</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">readData</span><span class="p">(</span><span class="s">&#39;/home/mtllab/pharmaco/saline_mean.mhd&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>Then, let&#8217;s set all the voxels outside of the cortex to 0 and write the result:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">heatmap</span><span class="p">[</span><span class="n">outside</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">writeData</span><span class="p">(</span><span class="s">&#39;/home/mtllab/Documents/pharmaco/saline_cortex.mhd&#39;</span><span class="p">,</span> <span class="n">heatmap</span><span class="p">);</span>
</pre></div>
</div>
<p>In the same fashion, you can include or exclude regions easily by using the annotation files. You can then open the stacks saved in ImageJ for instance and use one of the 3D viewers to look at the region isolated in 3D.</p>
<p>This concludes this tutorial, which should contain enough information to get you started. The next chapter will show a few examples of the effect of the various filters included in ClearMap for cell detection, and the following chapter is a reference that covers in detail all the included functions of ClearMap.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="imageanalysis.html" title="ClearMap Image Analysis Tools"
             >next</a> |</li>
        <li class="right" >
          <a href="installation.html" title="Installation"
             >previous</a> |</li>
       <li><a href="index.html">home</a>|&nbsp;</li>
       <li><a href="search.html">search</a>|&nbsp;</li>
       <li><a href="api/ClearMap.html">documentation </a> &raquo;</li>
 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2016 Christoph Kirst.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.3.
    </div>
  </body>
</html>